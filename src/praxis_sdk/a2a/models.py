"""
A2A (Agent-to-Agent) Protocol Models

Comprehensive Pydantic models implementing the A2A protocol specification
from https://a2a-protocol.org with full JSON-RPC 2.0 compliance.
"""

import time
from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Literal, Optional, Union
from uuid import uuid4

from pydantic import BaseModel, Field, field_validator, ValidationInfo


class TaskState(str, Enum):
    """Task execution states according to A2A specification."""
    
    SUBMITTED = "submitted"
    WORKING = "working"
    COMPLETED = "completed"
    FAILED = "failed"
    INPUT_REQUIRED = "input-required"


class MessageRole(str, Enum):
    """Message role types."""
    
    USER = "user"
    AGENT = "agent"


class PartKind(str, Enum):
    """Part content types."""
    
    TEXT = "text"
    FILE = "file"
    DATA = "data"


class A2AFile(BaseModel):
    """File attachment model."""
    
    name: Optional[str] = None
    mime_type: Optional[str] = Field(None, alias="mimeType")
    bytes: Optional[str] = None  # base64 encoded
    uri: Optional[str] = None
    
    model_config = {
        "populate_by_name": True
    }


class Part(BaseModel):
    """Smallest unit of content within a Message or Artifact."""
    
    kind: PartKind
    text: Optional[str] = None
    file: Optional[A2AFile] = None
    data: Optional[Any] = None
    
    @field_validator('text')
    @classmethod
    def validate_text_part(cls, v, info: ValidationInfo):
        if info.data.get('kind') == PartKind.TEXT and not v:
            raise ValueError('Text parts must have text content')
        return v
    
    @field_validator('file')
    @classmethod
    def validate_file_part(cls, v, info: ValidationInfo):
        if info.data.get('kind') == PartKind.FILE and not v:
            raise ValueError('File parts must have file content')
        return v
    
    @field_validator('data')
    @classmethod
    def validate_data_part(cls, v, info: ValidationInfo):
        if info.data.get('kind') == PartKind.DATA and v is None:
            raise ValueError('Data parts must have data content')
        return v


class Message(BaseModel):
    """Communication turn between client and agent."""
    
    role: MessageRole
    parts: List[Part]
    message_id: str = Field(alias="messageId", default_factory=lambda: str(uuid4()))
    task_id: Optional[str] = Field(None, alias="taskId")
    context_id: Optional[str] = Field(None, alias="contextId")
    kind: Literal["message"] = Field(default="message")
    
    model_config = {
        "populate_by_name": True
    }


class TaskStatus(BaseModel):
    """Current state of a task."""
    
    state: TaskState
    message: Optional[Message] = None
    timestamp: str = Field(default_factory=lambda: datetime.utcnow().isoformat() + "Z")


class Artifact(BaseModel):
    """Output generated by the agent as a result of a task."""
    
    artifact_id: str = Field(alias="artifactId", default_factory=lambda: str(uuid4()))
    name: Optional[str] = None
    description: Optional[str] = None
    parts: List[Part]
    metadata: Optional[Dict[str, Any]] = None
    
    model_config = {
        "populate_by_name": True
    }


class Task(BaseModel):
    """Fundamental unit of work managed by A2A."""
    
    id: str = Field(default_factory=lambda: str(uuid4()))
    context_id: str = Field(alias="contextId", default_factory=lambda: str(uuid4()))
    status: TaskStatus
    history: List[Message] = Field(default_factory=list)
    artifacts: List[Artifact] = Field(default_factory=list)
    metadata: Optional[Dict[str, Any]] = None
    kind: Literal["task"] = Field(default="task")
    
    model_config = {
        "populate_by_name": True
    }


class RPCError(BaseModel):
    """JSON-RPC error object."""
    
    code: int
    message: str
    data: Optional[Any] = None


class JSONRPCRequest(BaseModel):
    """JSON-RPC 2.0 request."""
    
    jsonrpc: Literal["2.0"] = Field(default="2.0")
    id: Union[str, int]
    method: str
    params: Optional[Dict[str, Any]] = None


class JSONRPCResponse(BaseModel):
    """JSON-RPC 2.0 response."""
    
    jsonrpc: Literal["2.0"] = Field(default="2.0")
    id: Union[str, int]
    result: Optional[Any] = None
    error: Optional[RPCError] = None
    
    @field_validator('error')
    @classmethod
    def validate_error_result_mutual_exclusion(cls, v, info: ValidationInfo):
        if v is not None and info.data.get('result') is not None:
            raise ValueError('Response cannot have both result and error')
        return v
    
    @field_validator('result')
    @classmethod
    def validate_result_error_mutual_exclusion(cls, v, info: ValidationInfo):
        if v is not None and info.data.get('error') is not None:
            raise ValueError('Response cannot have both result and error')
        return v


# A2A JSON-RPC Error Codes (matching Go SDK)
class A2AErrorCode:
    TASK_NOT_FOUND = -32001
    INVALID_PARAMS = -32602
    METHOD_NOT_FOUND = -32601
    INTERNAL_ERROR = -32603
    PARSE_ERROR = -32700


# A2A Method Parameter Models

class MessageSendParams(BaseModel):
    """Parameters for message/send method."""
    
    message: Message


class TasksGetParams(BaseModel):
    """Parameters for tasks/get method."""
    
    id: str


class TasksListParams(BaseModel):
    """Parameters for tasks/list method."""
    
    state: Optional[TaskState] = None
    limit: Optional[int] = Field(default=100, ge=1, le=1000)
    offset: Optional[int] = Field(default=0, ge=0)


# A2A Agent Card Models (Full Specification Compliance)

class A2ASkill(BaseModel):
    """Agent skill definition."""
    
    id: str
    name: str
    description: str
    tags: List[str] = Field(default_factory=list)


class A2ACapabilities(BaseModel):
    """Agent capabilities."""
    
    streaming: Optional[bool] = None
    push_notifications: Optional[bool] = Field(None, alias="pushNotifications")
    state_transition_history: Optional[bool] = Field(None, alias="stateTransitionHistory")
    
    model_config = {
        "populate_by_name": True
    }


class A2AProvider(BaseModel):
    """Agent provider information."""
    
    name: str
    version: Optional[str] = None
    description: Optional[str] = None
    url: Optional[str] = None


class A2AAgentCard(BaseModel):
    """Complete A2A agent card according to specification."""
    
    protocol_version: str = Field(alias="protocolVersion", default="0.3.0")
    name: str
    description: str
    url: str
    preferred_transport: str = Field(alias="preferredTransport", default="JSONRPC")
    additional_interfaces: List[str] = Field(alias="additionalInterfaces", default_factory=list)
    capabilities: A2ACapabilities = Field(default_factory=A2ACapabilities)
    skills: List[A2ASkill] = Field(default_factory=list)
    default_input_modes: List[str] = Field(alias="defaultInputModes", default_factory=lambda: ["application/json", "text/plain"])
    default_output_modes: List[str] = Field(alias="defaultOutputModes", default_factory=lambda: ["application/json", "text/plain"])
    provider: Optional[A2AProvider] = None
    security_schemes: Optional[Dict[str, Any]] = Field(None, alias="securitySchemes")
    metadata: Optional[Dict[str, Any]] = None
    
    # Compatibility fields
    version: Optional[str] = None
    supported_transports: Optional[List[str]] = Field(None, alias="supportedTransports")
    
    model_config = {
        "populate_by_name": True
    }


# Helper Functions for Creating A2A Objects

def create_task(context_id: Optional[str] = None, initial_message: Optional[Message] = None) -> Task:
    """Create a new task with default values."""
    
    task_id = str(uuid4())
    if context_id is None:
        context_id = str(uuid4())
    
    status = TaskStatus(state=TaskState.SUBMITTED)
    history = [initial_message] if initial_message else []
    
    # Update message with task and context IDs if provided
    if initial_message:
        initial_message.task_id = task_id
        initial_message.context_id = context_id
    
    return Task(
        id=task_id,
        context_id=context_id,
        status=status,
        history=history
    )


def create_message(
    role: MessageRole, 
    parts: List[Part], 
    message_id: Optional[str] = None,
    task_id: Optional[str] = None,
    context_id: Optional[str] = None
) -> Message:
    """Create a new message."""
    
    return Message(
        role=role,
        parts=parts,
        message_id=message_id or str(uuid4()),
        task_id=task_id,
        context_id=context_id
    )


def create_text_part(text: str) -> Part:
    """Create a text part."""
    
    return Part(kind=PartKind.TEXT, text=text)


def create_file_part(file: A2AFile) -> Part:
    """Create a file part."""
    
    return Part(kind=PartKind.FILE, file=file)


def create_data_part(data: Any) -> Part:
    """Create a data part."""
    
    return Part(kind=PartKind.DATA, data=data)


def create_artifact(
    name: str, 
    parts: List[Part], 
    description: Optional[str] = None,
    metadata: Optional[Dict[str, Any]] = None
) -> Artifact:
    """Create a new artifact."""
    
    return Artifact(
        name=name,
        parts=parts,
        description=description,
        metadata=metadata
    )


def create_rpc_error(code: int, message: str, data: Optional[Any] = None) -> RPCError:
    """Create a new RPC error."""
    
    return RPCError(code=code, message=message, data=data)


def create_jsonrpc_response(request_id: Union[str, int], result: Any) -> JSONRPCResponse:
    """Create a successful JSON-RPC response."""
    
    return JSONRPCResponse(id=request_id, result=result)


def create_jsonrpc_error_response(request_id: Union[str, int], error: RPCError) -> JSONRPCResponse:
    """Create an error JSON-RPC response."""
    
    return JSONRPCResponse(id=request_id, error=error)


# Standard A2A agent capabilities
def create_default_capabilities() -> A2ACapabilities:
    """Create default agent capabilities."""
    
    return A2ACapabilities(
        streaming=True,
        push_notifications=True,
        state_transition_history=True
    )


# Standard A2A skills for Praxis agents
def create_praxis_skills() -> List[A2ASkill]:
    """Create standard Praxis agent skills."""
    
    return [
        A2ASkill(
            id="python-execution",
            name="Python Code Execution",
            description="Execute Python scripts and analyze data",
            tags=["python", "coding", "analysis"]
        ),
        A2ASkill(
            id="file-operations",
            name="File Operations",
            description="Read, write, and manipulate files in shared workspace",
            tags=["filesystem", "io"]
        ),
        A2ASkill(
            id="data-processing",
            name="Data Processing",
            description="Process and analyze data using various tools",
            tags=["data", "analysis"]
        ),
        A2ASkill(
            id="workflow-orchestration",
            name="Workflow Orchestration",
            description="Coordinate complex multi-step workflows across agents",
            tags=["orchestration", "workflow", "dsl"]
        ),
        A2ASkill(
            id="p2p-communication",
            name="P2P Communication",
            description="Communicate with other agents via P2P network",
            tags=["p2p", "networking", "collaboration"]
        )
    ]


def create_skills_from_tools(tools: List) -> List[A2ASkill]:
    """Create A2A skills from configured tools."""
    skills = []
    
    # Map common tool names to skill categories
    tool_skill_mapping = {
        "write_file": "file-operations",
        "read_file": "file-operations", 
        "list_files": "file-operations",
        "python_analyzer": "python-execution",
        "execute_python": "python-execution",
        "code_execution": "python-execution",
    }
    
    for tool in tools:
        tool_name = getattr(tool, 'name', str(tool))
        tool_description = getattr(tool, 'description', f"Tool: {tool_name}")
        
        # Determine skill category
        skill_id = tool_skill_mapping.get(tool_name, f"tool-{tool_name}")
        
        # Create appropriate tags based on tool name
        tags = ["tool"]
        if "file" in tool_name.lower():
            tags.extend(["filesystem", "io"])
        elif "python" in tool_name.lower() or "code" in tool_name.lower():
            tags.extend(["python", "execution", "analysis"])
        elif "data" in tool_name.lower():
            tags.extend(["data", "processing"])
        
        skills.append(A2ASkill(
            id=skill_id,
            name=tool_name.replace("_", " ").title(),
            description=tool_description,
            tags=tags
        ))
    
    return skills


def create_dynamic_agent_card(
    name: str,
    description: str,
    url: str,
    tools: Optional[List] = None,
    additional_skills: Optional[List[A2ASkill]] = None,
    provider: Optional[A2AProvider] = None
) -> A2AAgentCard:
    """Create a dynamic A2A agent card based on available tools and configuration."""
    
    # Start with standard Praxis skills
    skills = create_praxis_skills()
    
    # Add skills from tools if provided
    if tools:
        tool_skills = create_skills_from_tools(tools)
        skills.extend(tool_skills)
    
    # Add any additional custom skills
    if additional_skills:
        skills.extend(additional_skills)
    
    # Remove duplicate skills by ID
    unique_skills = {}
    for skill in skills:
        if skill.id not in unique_skills:
            unique_skills[skill.id] = skill
    
    # Set default provider if not provided
    if not provider:
        provider = A2AProvider(
            name="Praxis",
            url="https://praxis.ai",
            description="Advanced AI agent framework with P2P networking and MCP integration"
        )
    
    return A2AAgentCard(
        name=name,
        description=description,
        url=url,
        skills=list(unique_skills.values()),
        capabilities=create_default_capabilities(),
        provider=provider
    )